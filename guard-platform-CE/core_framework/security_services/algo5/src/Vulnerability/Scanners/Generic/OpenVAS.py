#!/usr/bin/python3

from ..Scanner import Scanner
from Utils.Misc import uuid, jload
from Utils.Logger import Logger

from gvm.connections import TLSConnection
from gvm.protocols.gmpv7 import Gmp, AliveTest
from gvm.transforms import EtreeCheckCommandTransform
from gvm.errors import GvmError

import os, enum

class OpenVAS(Scanner):
	""" OpenVAS wrapper class used by the Orchestrator to configure scans, initiate them and collect results.
	"""

	_caller_prefix = "OpenVAS"
	_abs_path = os.path.dirname(os.path.abspath(__file__))
	# Base config file -- remote GVM hostname, port, credentials, default port list
	_config_file = os.path.join(_abs_path, "configs/openvas_config.json")
	_base_config = jload(_config_file)

	_min_qod = 50

	""" Connects to the remote GVM and authenticates
	"""
	def __init__(self, config):
		self._config = config
		self._gmp = OpenVAS._create_gmp()
		self._scanner_id = self._get_default_scanner()
		self._default_port_list = False # Bool to indicate if we should delete the port list at cleanup or not (we used a default one)
		self._tasks = {} # key: host, value: dict (see in `bootstrap` below)
		
	def __del__(self):
		OpenVAS._disconnect_gmp(self._gmp)

	@classmethod
	def _create_gmp(cls):
		connection = TLSConnection(hostname = OpenVAS._base_config["hostname"], port = OpenVAS._base_config["port"])
		transform = EtreeCheckCommandTransform()
		gmp = Gmp(connection = connection, transform = transform)
		gmp.connect() # Gmp.disconnect() will be called on GC
		gmp.authenticate(OpenVAS._base_config["username"], OpenVAS._base_config["password"])
		return gmp

	@classmethod
	def _disconnect_gmp(cls, gmp):
		gmp.disconnect()

	""" Create corresponding OpenVAS targets, port lists and tasks
	"""
	def bootstrap(self):
		for host_info in self._config["hosts"]: # Separate task for each specified host
			if not host_info.get("openvas", None): continue # No openvas scanning for this host
			host = host_info["host"]
			host_info = host_info["openvas"]
			self._tasks[host] = {}

			Logger.spit("Setting up %s instance for %s" % (OpenVAS._caller_prefix, host), caller_prefix = OpenVAS._caller_prefix)

			if "ports" not in host_info:
				Logger.spit("Incorrect config format: \"ports\" list is missing", error = True, caller_prefix = OpenVAS._caller_prefix)
				return False
			self._tasks[host]["port_list_id"] = self._setup_portlist(host_info.get("ports"))
			self._tasks[host]["target_id"] = self._setup_target(host, self._tasks[host]["port_list_id"])

			scanning_config = host_info.get("scan", None)
			if scanning_config not in set([scan.value for scan in Scans]):
				Logger.spit("Scanning configuration does not exist: %s" % scanning_config, error = True, caller_prefix = OpenVAS._caller_prefix)
				return False

			self._tasks[host]["qod"] = host_info.get("qod", OpenVAS._min_qod) # QoD threshold for findings

			self._tasks[host]["scan_id"] = self._get_scan_id(host_info.get("scan"))
			self._tasks[host]["task_id"] = self._setup_task(host, self._tasks[host]["scan_id"], self._tasks[host]["target_id"])
			self._tasks[host]["status"] = "Pending"
			self._tasks[host]["results"] = []

		if not self._tasks: return False # Not enabled for any host or misconfigurations occured
		return True

	def start(self):
		for host in self._tasks:
			self._gmp.start_task(self._tasks[host]["task_id"])
			self._tasks[host]["status"] = "Running"

	""" Returns True if all tasks have finished, otherwise False
	"""
	def status(self):
		done = True
		for host in self._tasks:
			if self._tasks[host]["status"] == "Done":
				continue
			done = False # If at least one task is still running, keep polling
			
			task = self._gmp.get_task(self._tasks[host]["task_id"]).find("task")
			if task.find("status").text != "Done":
				continue

			self._collect_results(task, host) # Collect results on each individual task when finished
			self._cleanup(host) # Cleanup stored objects (port lists, targets etc..)
			self._tasks[host]["status"] = "Done"
			Logger.spit("Completed scan for %s (%s results)" % (host, len(self._tasks[host]["results"])), caller_prefix = OpenVAS._caller_prefix)
		return done

	""" Create results' object for given task/host
	"""
	def _collect_results(self, task, host):
		report_id = task.find("last_report/report").get("id") # Get final report UUID
		self._tasks[host]["report_id"] = report_id
		report = self._gmp.get_report(report_id).find("report").find("report") # And fetch it

		for result in report.find("results").getchildren():
			result_artifact = {}
			result_artifact["name"] = result.find("name").text
			result_artifact["threat"] = result.find("threat").text
			result_artifact["severity"] = result.find("severity").text
			result_artifact["description"] = result.find("description").text
			result_artifact["nvt_family"] = result.find("nvt").find("family").text
			result_artifact["cvss_base"] = result.find("nvt").find("cvss_base").text
			result_artifact["cve"] = result.find("nvt").find("cve").text
			result_artifact["qod"] = int(result.find("qod").find("value").text)
			result_artifact["qod_type"] = result.find("qod").find("type").text
			if result_artifact["qod"] < self._tasks[host]["qod"]: continue # Do not include findings with QoD less than the given threshold
			self._tasks[host]["results"].append(result_artifact)


	""" Either create a new OpenVAS port list and return its UUID OR return the default port list
	"""
	def _setup_portlist(self, port_list):
		if port_list: # Create new port list with random name and return its UUID
			ports_str = ""
			if "tcp" in port_list: ports_str = "T: %s" % (", ".join(map(str, port_list["tcp"])))
			if "udp" in port_list: ports_str += "%sU: %s" % (", " if ports_str else "", ", ".join(map(str, port_list["udp"])))
			if ports_str: return self._gmp.create_port_list(uuid(), ports_str).get("id")

		for pl in self._gmp.get_port_lists().xpath("port_list"): # Locate default port list's UUID
			if pl.find("name").text == OpenVAS._base_config["default_port_list"]:
				self._default_port_list = True
				return pl.get("id")
	
	""" Setup an OpenVAS target object for the given host and return its UUID
	"""
	def _setup_target(self, host, port_list_id):
		target_name = "%s-%s" % (host, uuid())
		return self._gmp.create_target(target_name, hosts = [host], port_list_id = port_list_id, alive_test = AliveTest.CONSIDER_ALIVE).get("id")

	""" Return default scanner's UUID
	"""
	def _get_default_scanner(self):
		for scanner in self._gmp.get_scanners().xpath("scanner"):
			if scanner.find("name").text == OpenVAS._base_config["default_scanner"]:
				return scanner.get("id")

	""" Return selected config's UUID
	"""
	def _get_scan_id(self, scan_name):
		if not scan_name:
			scan_name = OpenVAS._base_config["default_scan_config"]
		if scan_name not in set([scan.value for scan in Scans]):
			raise Exception("Unrecognized scan (%s)" % scan_name)
		for scan in self._gmp.get_configs(filter = "name:%s$" % scan_name).xpath("config"):
			if scan_name in scan.find("name").text:
				return scan.get("id")

	""" Create a new task object
	"""
	def _setup_task(self, host, scan_id, target_id):
		task_name = "%s-%s" % (host, uuid())
		return self._gmp.create_task(task_name, scan_id, target_id, self._scanner_id).get("id")

	def get_results(self):
		return self._tasks

	""" Delete all OpenVAS objects created for a specific task
	"""
	def _cleanup(self, host):
		self._gmp.delete_task(self._tasks[host]["task_id"])
		self._gmp.delete_target(self._tasks[host]["target_id"])
		if not self._default_port_list:
			self._gmp.delete_port_list(self._tasks[host]["port_list_id"])
		self._gmp.delete_report(self._tasks[host]["report_id"])
		self._tasks[host].pop("task_id")
		self._tasks[host].pop("target_id")
		self._tasks[host].pop("port_list_id")
		self._tasks[host].pop("report_id")
		self._tasks[host].pop("scan_id")

	""" Delete all OpenVAS objects created since the beginning of time
	"""
	@classmethod
	def _cleanup_all(cls):
		gmp = OpenVAS._create_gmp()
		# Cleanup tasks
		tasks = gmp.get_tasks()
		Logger.spit("Cleaning up tasks (%s)..." % len(tasks), caller_prefix = OpenVAS._caller_prefix)
		for task in tasks:
			task_id = task.get("id")
			if task_id: gmp.delete_task(task_id)

		# Cleanup targets
		targets = gmp.get_targets()
		Logger.spit("Cleaning up targets (%s)..."% len(targets), caller_prefix = OpenVAS._caller_prefix)
		for target in targets:
			target_id = target.get("id")
			if target_id:
				try: gmp.delete_target(target_id) # Catch exception on targets still in use
				except: continue

		# Cleanup port lists
		port_lists = gmp.get_port_lists()
		Logger.spit("Cleaning up port lists (%s)..." % len(port_lists), caller_prefix = OpenVAS._caller_prefix)
		for port_list in port_lists:
			port_list_id = port_list.get("id")
			if port_list_id:
				try: gmp.delete_port_list(port_list_id) # Catch exception on predefined port lists
				except: continue

		# Cleanup reports
		reports = gmp.get_reports()
		Logger.spit("Cleaning up reports (%s)..." % len(reports), caller_prefix = OpenVAS._caller_prefix)
		for report in reports:
			report_id = report.get("id")
			if report_id: gmp.delete_report(report_id)




""" Supported scan types. The input config file should match these
"""
class Scans(enum.Enum):
	FAST = "fast"
	FAST_ULTI = "fast ultimate"
	DEEP = "deep"
	DEEP_ULTI = "deep ultimate"