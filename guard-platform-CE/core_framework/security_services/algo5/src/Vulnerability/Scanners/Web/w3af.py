#!/usr/bin/python3

from ..Scanner import Scanner
from Utils.Misc import uuid, jload, free_port
from Utils.Logger import Logger

from w3af_api_client import Connection, Scan

from time import sleep
from hashlib import sha512
import os, psutil, enum, subprocess, signal, psutil

import urllib3 # Only included to disable warning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class w3af(Scanner):
	""" w3af wrapper class used by the Orchestrator to configure scans, initiate them and collect results.
	"""

	_caller_prefix = "w3af"
	
	_abs_path = os.path.dirname(os.path.abspath(__file__))
	_config_file = os.path.join(_abs_path, "configs/w3af_config.json")
	_base_config = jload(_config_file)

	_profiles_dir = _base_config["profiles_dir"]

	""" Create connection to w3af API endpoint
	"""
	def __init__(self, config):
		self._config = config
		self._tasks = {} # key: host, value: dict (see in `bootstrap` below)

	def bootstrap(self):
		for host_info in self._config["hosts"]: # Separate task for each specified host
			host = host_info["host"]
			if not host_info.get("w3af", None): continue # No w3af scanning for this host
			Logger.spit("Setting up %s instance for %s" % (w3af._caller_prefix, host), caller_prefix = w3af._caller_prefix)

			if "ports" not in host_info["w3af"]:
				Logger.spit("Incorrect config format: \"ports\" list is missing", error = True, caller_prefix = w3af._caller_prefix)
				return False
			port_list = host_info["w3af"]["ports"]

			self._tasks[host] = {}
			self._tasks[host]["scan_profile"] = host_info["w3af"].get("scan", None) # Scanning configuration. Should be one of Scans enum below
			if self._tasks[host]["scan_profile"] not in set([scan.value for scan in Scans]):
				Logger.spit("Scanning configuration does not exist: %s" % self._tasks[host]["scan_profile"], error = True, caller_prefix = w3af._caller_prefix)
				return False
			with open(os.path.join(w3af._profiles_dir, "%s.pw3af" % self._tasks[host]["scan_profile"])) as fp:
				self._tasks[host]["scan_profile"] = fp.read()

			self._tasks[host]["target_urls"] = ["http://%s:%s" % (host, port) for port in port_list]

			""" w3af does not support concurrent scans so we need to create new w3af instances (on different ports) for each task/host
			""" 
			self._tasks[host]["w3af_proc"], self._tasks[host]["port"] = self._launch_w3af_api()
			self._tasks[host]["connection"] = Connection('https://%s:%s@%s:%s/' % (w3af._base_config["username"], w3af._base_config["password"], w3af._base_config["host"], self._tasks[host]["port"]), timeout = w3af._base_config["timeout"], verify = False)

			self._tasks[host]["scan"] = Scan(self._tasks[host]["connection"])
			self._tasks[host]["status"] = "Pending"
			self._tasks[host]["results"] = []

		if not self._tasks: return False # Not enabled for any host or misconfigurations occured
		return True

	""" Launch w3af_api subprocess and return it along with the port running
	"""
	def _launch_w3af_api(self):
		port = free_port()
		w3af_proc = subprocess.Popen([w3af._base_config["w3af_api"], "-p", sha512(bytes(w3af._base_config["password"], "utf-8")).hexdigest(), "%s:%s" % (w3af._base_config["host"], str(port))], stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
		sleep(w3af._base_config["api_boot_sleep"]) # Make sure the process started
		return w3af_proc, port

	def start(self):
		for host, host_config in self._tasks.items():
			host_config["scan"].start(host_config["scan_profile"], host_config["target_urls"])
			self._tasks[host]["status"] = "Running"
			sleep(w3af._base_config["task_start_sleep"]) # Make sure the task was created

	""" Returns True if all tasks have finished, otherwise False
	"""
	def status(self):
		done = True
		for host in self._tasks:
			if self._tasks[host]["status"] == "Done":
				continue
			done = False # If at least one task is still running, keep polling

			try: status = self._tasks[host]["scan"].get_status()["status"] # get_status often throws a TimeoutException
			except Exception as e: continue
			if status == "Running":
				continue

			self._collect_results(host)
			self._cleanup(host)
			self._tasks[host]["status"] = "Done"
			Logger.spit("Completed scan for %s" % host, caller_prefix = w3af._caller_prefix)
		return done

	def _collect_results(self, host):
		for finding in self._tasks[host]["scan"].get_findings():
			self._tasks[host]["results"].append(finding.resource_data)

	def _get_default_scanner(self):
		with open(os.path.join(w3af._profiles_dir, "%s.pw3af" % w3af._base_config["default_scan_profile"])) as fp:
			return fp.read()

	def get_results(self):
		return self._tasks

	def _cleanup(self, host):
		self._tasks[host]["scan"].cleanup()
		self._tasks[host].pop("scan_profile")
		self._tasks[host].pop("target_urls")
		self._tasks[host].pop("scan")
		self._tasks[host].pop("port")
		self._tasks[host].pop("connection")
		self._tasks[host].pop("w3af_proc").send_signal(signal.SIGINT) # Stop the w3af process for this task

	""" Kill all running w3af instances
	"""
	@classmethod
	def _cleanup_all(cls):
		killed = set()
		for pid in psutil.pids():
			if not psutil.pid_exists(pid):
				continue
			proc = psutil.Process(pid)
			proc_string = " ".join([proc.name()] + proc.cmdline())
			if w3af._caller_prefix in proc_string:
				proc.terminate()
				killed.add(pid)
		Logger.spit("Killed %s processes..." % len(killed), caller_prefix = w3af._caller_prefix)

""" Supported scan types. The input config file should match these
"""
class Scans(enum.Enum):
	BRUTE = "bruteforce"
	HIGH_RISK = "audit_high_risk"
	FULL = "full_audit"
	OWASP = "OWASP_TOP10"
	FAST = "fast_scan"
	INFRASTRUCTURE = "web_infrastructure"